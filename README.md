# HTML builder
---

### Цели:

В данной серии заданий основной целью является понимание основ работы с платформой Node.js.  
Вам предлагается выполнить серию небольших задач с нарастающей сложностью, и в финале создать небольшую утилиту по сборке статического сайта. 

Обратите внимание, что большинство задач можно выполнить несколькими способами и на данном этапе неправильных среди них нет. Оценивается только работоспособность вашего кода и выполнение поставленных условий. 

---

### Общие правила:

- Запрещается использование любых сторонних модулей
- Каждое из заданий должно запускаться командой node <имя папки задания> выполненной в корневой директории

## Оглавление
[01 Чтение файла с выводом содержимого в консоль](#чтение-файла-с-выводом-содержимого-в-консоль)  
[02 Запись консольного ввода в файл](#запись-консольного-ввода-в-файл)  
[03 Вывод информации о файлаx хранящихся в папке](#вывод-информации-о-файлаx-хранящихся-в-папке)  
[04 Сборка css бандла](#сборка-css-бандла)  
[05 Сборка HTML страницы](#сборка-HTML-страницы-из-компонентов)  



## Чтение файла с выводом содержимого в консоль

В файле **index.js** директории **01-read-file** напишите скрипт выводящий в консоль содержимое файла **text.txt**. 


### Требования

- [ ] Внутри папки ***01-read-file*** находятся 2 файла **index.js** и **text.txt**
- [ ] При выполнении команды ```node 01-read-file``` в корневом каталоге репозитория в консоль выводится содержимое файла **text.txt**. 
- [ ] В коде не должны быть использованы синхронные методы чтения файла.
- [ ] Чтение файла должно происходить с помощью **ReadStream**.


### Цели задания
- Познакомиться с основами работы с файловой системой на платформе Node.Js
- Изучить основы streams и events
- Ознакомиться с модулем Path и научиться применять его для построения абсолютного пути к фалам.  

### Описание  
В данном задании от вас требуется написать небольшой скрипт, результатом работы которого будет вывод содержимого заранее подготовленного текстового файла в консоль. Для этого вы можете придерживаться данного порядка действий:  

1. Импортировать необходимые для выполнения задания модули:
- Для взаимодействия с файловой системой в NodeJs используется модуль fs, документацию которого можно найти по этой [ссылке](https://nodejs.org/api/fs.html#fs_file_system)(перевод на русский приложен в разделе "Полезные ссылки"). 
- Для корректного указания пути к файлу вам понадобится модуль [Path](https://nodejs.org/api/path.html#path_path_join_paths). 
2. Создать новый **ReadStream** из файла **text.txt**. 
3. Направить поток чтения в стандартный поток вывода.  

### Советы
Для импорта в Node.js используйте [CommonJS modules](https://nodejs.org/docs/latest/api/modules.html#modules_modules_commonjs_modules). Несмотря на то, что в настоящее время Node.js уже имеет почти полную поддержку **ECMAScript modules**(import/export), данный подход ещё не полностью стабилен и подавляющее большинство кода с которым вы столкнётесь будет написано с помощью **CommonJS**.  
Прим: ```const fs = require('fs');```  

Для считывания файла вы будете использовать потоки ([streams](https://nodejs.org/api/stream.html#stream_readable_streams)), которые являются важной и полезной частью платформы. Благодаря им, вы можете налету обрабатывать огромные количества данных по чанку за раз, при этом расходуя минимальное количество ресурсов, вместо того, чтобы выгружать их в память целиком. В дальнейшем вы не раз столкнётесь с ними в своей работе.
Так же, важным моментом будет ознакомление с ещё одной базовой концепцией платформы Node.js, а именно **Events**(события). Node.js использует события почти повсеместно, а большинство объектов являются наследниками класса **EventEmitter**. Для более полного понимания работы потоков при изучении рекомендую сначала ознакомиться именно с событиями, так как каждый поток является наследником **EventEmitter**.
Материалы по данным темам так же приложены в разделе "Полезные ссылки".


При создании **ReadStream** обратите внимание на то, что команда запуска вашего кода должна выполняться в корневой директории репозитория, а следовательно важно правильно передать путь к файлу для чтения. Node.js, в случае передачи относительного пути к файлу вроде ```./text.txt``` будет искать его относительно директории в которой был запущен процесс. Функция **join** из модуля [Path](https://nodejs.org/api/path.html#path_path_join_paths) позволяет создать полный путь к текстовому файлу основываясь на переменной  [__dirname](https://js-node.ru/site/article?id=24#globals_dirname) хранящей путь к каталогу, где находится файл вашего скрипта. Таким образом директория из которой вы запускаете код не повлияет на место поиска нужного файла и вы всегда будете ссылаться на **text.txt** лежащий рядом с **index.js**. Так же модуль [Path](https://node.js.org/api/path.html#path_path_join_paths) содержит другие полезные функции для манипуляций с путями, а потому настоятельно рекомендую изучить его возможности.

У вас будет несколько вариантов для того, чтобы направить ваш поток чтения в поток стандартного вывода(то есть консоль. Больше о стандартных потоках можно узнать [тут](https://ru.wikipedia.org/wiki%D0%A1%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D0%BD%D1%8B%D0%B5_%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%B8)), 
Вы можете использовать как высокоуровневый [console.log()](https://nodejs.org/api/console.html#console_console_log_data_args), так и работать напрямую с потоком вывода [process.stdout](https://nodejs.org/api/process.html#process_process_stdout).  


##### Полезные ссылки
*Обратите внимание, что переводы документации на русский язык могут быть устаревшими и не содержать всех современных возможностей модулей. Однако, основные концепции описанные там работают и по сей день. Для получения актуальной информации всегда используйте официальную документацию!*
- События:  
    - [События от Metanit](https://metanit.com/web/nodejs/2.9.php)
    - [Understanding Node.js Event-Driven Architecture (FreeCodeCamp)](https://www.freecodecamp.org/news/understanding-node-js-event-driven-architecture-223292fcbc2d/)
    - [Event emitter (nodejsdev.ru)](https://nodejsdev/learn/the-node.js-event-emitter)  
    - [Перевод документации Events (nodejsdev.ru)](https://nodejsdev.ru/api/events/)  
    - [События гайд (nodejsdev.ru)](https://nodejsdev.ru/guide/events/) 
- Потоки:
    - [Stream](https://nodejs.org/api/stream.html)  
    - [Stream перевод на русский](https://js-node.ru/site/article?id=41)
    - [fs.createReadStream](https://nodejs.org/api/fs.html#fs_fs_createreadstream_path_options)
    - [Потоки (nodejsdev.ru)](https://nodejsdev.ru/api/stream/)
    - [Pipe (nodejsdev.ru)](https://nodejsdev.ru/guide/pipe/)
    - [Stream от Metanit](https://metanit.com/web/nodejs/2.10.php)  
    - [Pipe от Metanit](https://metanit.com/web/nodejs/2.11.php)   
- Модуль Path:
    - [Path](https://nodejs.org/api/path.html)   
    - [Path перевод на русский](https://nodejs.org/api/path.html#path_path)
- Process: 
    - [Process](https://nodejs.org/api/process.html)
    - [Process перевод на русский](https://nodejsdev.ru/api/process/)
---

## Запись консольного ввода в файл

В файле **index.js** директории **02-write-file** напишите скрипт выводящий в консоль приветствие, ожидающий ввод текста, и записывающий введённый текст в файл.


### Требования

- [ ] Внутри папки 02-write-file находится 1 файл **index.js**
- [ ] При выполнении команды ```node 02-write-file``` в корневом каталоге репозитория в консоль выводится приглашение на ввод текста(На ваш выбор).
- [ ] После ввода текста в каталоге ```02-write-file``` должен быть создан текстовый файл, а введённый текст записан в него. Процесс не завершается и ждёт нового ввода.
- [ ] После следующего ввода созданный изначально текстовый файл дополняется новым текстом, процесс продолжает ждать ввод.
- [ ] При нажатии сочетания клавиш ```ctrl + c``` или вводе ```exit``` в консоль выводится прощальная фраза и процесс завершается.


### Цели задания
- Укрепить понимание основ работы событий и потоков в Node.js
- Работа с глобальным объектом process

### Описание
В данном задании вам предстоит написать программу считывающую ваш консольный ввод до момента принудительного завершения процесса ```ctrl + c``` или ввода ключевого слова **exit**. Порядок действий для выполнения задачи:
1. Импорт всех требуемых модулей.
2. Создание потока записи в текстовый файл
3. Вывод в консоль приветственного сообщения
4. Ожидание ввода текста пользователем, с дальнейшей проверкой ввода на наличие ключевого слова **exit**
5. Запись текста в файл
6. Ожидание дальнейшего ввода
7. Реализация прощального сообщения при остановке процесса

### Советы

Для успешного выполнения данного таска вам понадобятся знания о событиях и потоках приобретённые ранее, а так же следует изучить возможности глобального объекта process. Используя его события вы сможете, в том числе и перехватывать сигналы посылаемые процессу, например при нажатии ```ctrl + c```.

Читать что-либо из потока(stream) по строке за раз вам может помочь модуль Readline. Стандартный поток ввода stdin являясь ReadbleStream отлично подходит для этого. 

##### Полезные ссылки
*Обратите внимание, что переводы документации на русский язык могут быть устаревшими и не содержать всех современных возможностей модулей. Однако, основные концепции описанные там работают и по сей день. Для получения актуальной информации всегда используйте официальную документацию!*
- Process: 
    - [Process](https://nodejs.org/api/process.html)
    - [Process перевод на русском (nodejsdev.ru)](https://nodejsdev.ru/api/process/)
    - [Signal events](https://nodejs.org/api/process.html#process_signal_events)
    - [Сигнальные события (nodejsdev.ru)](https://nodejsdev.ru/api/process/#signal-events)
- Readline:
    - [Readline](https://nodejs.org/api/readline.html)
    - [Readline на русском (nodejsdev.ru)]()
- События:  
    - [События от Metanit](https://metanit.com/web/nodejs/2.9.php)
    - [Understanding Node.js Event-Driven Architecture (FreeCodeCamp)](https://www.freecodecamp.org/news/understanding-node-js-event-driven-architecture-223292fcbc2d/)
    - [Event emitter (nodejsdev.ru)](https://nodejsdev/learn/the-node.js-event-emitter)  
    - [Перевод документации Events (nodejsdev.ru)](https://nodejsdev.ru/api/events/)  
    - [События гайд (nodejsdev.ru)](https://nodejsdev.ru/guide/events/) 
- Потоки:
    - [Stream](https://nodejs.org/api/stream.html)  
    - [Stream перевод на русский](https://js-node.ru/site/article?id=41)
    - [fs.createReadStream](https://nodejs.org/api/fs.html#fs_fs_createreadstream_path_options)
    - [Потоки (nodejsdev.ru)](https://nodejsdev.ru/api/stream/)
    - [Pipe (nodejsdev.ru)](https://nodejsdev.ru/guide/pipe/)
    - [Stream от Metanit](https://metanit.com/web/nodejs/2.10.php)  
    - [Pipe от Metanit](https://metanit.com/web/nodejs/2.11.php)  
- Модуль Path:
    - [Path](https://nodejs.org/api/path.html)   
    - [Path перевод на русский](https://nodejs.org/api/path.html#path_path)

---

## Вывод информации о файлаx хранящихся в папке

В файле **index.js** директории **03-files-in-folder** напишите скрипт выводящий в консоль данные о файлах содержащихся в папке **secret-folder**.
Данные должны быть выведены в формате <имя файла>-<расширение файла>-<вес файла кб>.
Пример: ```example - txt - 128kb```


### Требования

- [ ] Содержимое ***03-files-in-folder/secret-folder*** изначально должно соответствовать исходному репозиторию.
- [ ] При выполнении команды ```node 04-files-in-folder``` в корневом каталоге репозитория в консоль выводится информация о файлах содержащихся внутри ***03-files-in-folder/secret-folder***
- [ ] Информация должна выводиться только для файлов. Наличие информации о директориях считается ошибкой.


### Цели задания

- Научиться получать информацию о файлах.  

### Описание

Порядок действий для выполнения задачи:

1. Импорт всех требуемых модулей
2. Чтение содержимого папки secret-folder
3. Получение данных о каждом объекте который содержит папка secret-folder
4. Проверка объекта на то, что он является файлом
5. Вывод данных о файле в консоль

### Советы

Для того, чтобы прочесть содержимое папки, используйте функцию ```readdir``` из модуля "fs/promises"([ссылка на документацию](https://nodejs.org/dist/latest-v16.x/docs/api/fs.html#fs_fspromises_readdir_path_options)). Данная функция позволит вам получить имена всех файлов находящихся в заданной директории.

После прочтения содержимого папки, в случае если вы установите опцию ```{withFileTypes: true}```, каждый объект содержащийся в ней будет представлен в виде инстанса класса [Dirent](https://nodejs.org/dist/latest-v16.x/docs/api/fs.html#fs_class_fs_dirent). Его методы позволят вам узнать, является ли объект файлом.

Для определения расширения файла вы можете использовать метод ```extname``` модуля "path". [Документация](https://nodejs.org/api/path.html#path_path_extname_path)

Получить информацию о файле поможет [stat](https://nodejs.org/dist/latest-v16.x/docs/api/fs.html#fs_fs_stat_path_options_callback). 
Полный перечень данных которые возвращает данная функция вы можете увидеть в документации. Обратите внимание, что возвращаемый данной функцией объект является инстансом класса [Stats](https://nodejs.org/dist/latest-v16.x/docs/api/fs.html#fs_class_fs_stats), который так же имеет методы позволяющие проверить является ли объект файлом.

##### Полезные ссылки
*Обратите внимание, что переводы документации на русский язык могут быть устаревшими и не содержать всех современных возможностей модулей. Однако, основные концепции описанные там работают и по сей день. Для получения актуальной информации всегда используйте официальную документацию!*

- [stat на русском (nodejsdev.ru)](https://nodejsdev.ru/api/fs/#fsstat)  
- [readdir на русском (nodejsdev.ru)](https://nodejsdev.ru/api/fs/#fsreaddir)  
- [Stats на русском (nodejsdev.ru)](https://nodejsdev.ru/api/fs/#fsstats)  


---

## Сборка css бандла

В файле **index.js** директории **04-merge-styles** напишите скрипт собирающий в единый файл содержимое папки css. Выходной файл должен носить имя **bundle.css** и находиться внутри папки **dist**.

### Требования

- [ ] После завершения работы скрипта в папке **dist** будет создан файл **bundle.css** содержащий стили из всех файлов папки **css**.
- [ ] При добавлении файлов стилей в папку **css** и повторном запуске скрипта файл **bundle.css** перезаписывается и содержит актуальные стили.
- [ ] Любые файлы имеющие расширение отличное от **css** игнорируются.

### Цели задания

- Научиться объединять информацию из нескольких файлов с одним расширением.

### Описание
Порядок действий для выполнения задачи:

1. Импорт всех требуемых модулей
2. Создание потока записи в файл **bundle.css**
3. Чтение содержимого папки **css**
4. Направление содержимого каждого файла с расширением **.css** в поток записи **bundle.css**.

Для наглядного эффекта работы вашего скрипта рекомендую установить в vscode расширение [Life Server](https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer) и запустить с его помощью файл **index.html** находящийся в директории **project-dist**.

---

## Сборка HTML страницы из компонентов

В файле **index.js** директории **05-merge-html** напишите скрипт заменяющий шаблонные теги  (пример: ```{{section-2}}```) с названиями файлов-компонентов из папки components на содержимое одноимённых компонентов и сохраняющий результат в папку **dist**.
### Требования
- [ ] После завершения работы скрипта создаётся папка **dist**. В папке находится файл **index.html**.
- [ ] В созданном файле теги заменены содержимым одноимённых компонентов
- [ ] Синтаксис тегов может быть изменён на ваше усмотрение
- [ ] При добавлении компонента в папку и соответствующего тега в исходный файл **index.html** повторное выполнение скрипта приведёт файл **index.html** в папке **dist** в актуальное состояние перезаписав его.
- [ ] Исходный файл **Index.html** не должен быть изменён в ходе выполнения скрипта.
- [ ] Извлечение и запись в шаблон содержимого любых файлов кроме файлов с расширением **.html** является ошибкой.

### Цели задания

- Научиться заменять шаблонные теги прочитанными из файла данными  

### Описание

Один из возможных порядков выполнения задачи:

1. Импорт всех требуемых модулей
2. Прочтение и сохранение в переменной файла-шаблона
3. Прочтение содержимого папки components
4. Замена шаблонных тегов содержимым файлов-компонентов
5. Запись изменённого шаблона в файл **index.html** в папке **dist**

Обратите внимание, что данный алгоритм вы можете оптимизировать и изменять по своему усмотрению, а так же вы можете самостоятельно выбирать синтаксис шаблонных тегов.
